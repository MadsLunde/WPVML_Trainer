// This file was auto-generated by ML.NET Model Builder. 

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;

using CsvHelper;

using Microsoft.ML;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;

using WPVML_Trainer;
using WPVML_Trainer.Models;

using WPVML_TrainerML.ConsoleApp.Helpers;
using WPVML_TrainerML.ConsoleApp.Helpers.ModelMappers;
using WPVML_TrainerML.ConsoleApp.Trainers;
using WPVML_TrainerML.Model;
using WPVML_TrainerML.Model.Executors;
using WPVML_TrainerML.Model.Models;

namespace WPVML_TrainerML.ConsoleApp
{
    class Program
    {
        static void Main(string[] args)
        {
            MLContext mlContext = new MLContext();
            Repository repo = new Repository();
            var sessions = repo.GetAlotOfTrainingSessions();

            UserMatrixFactorization.CreateModel(32, 200);

            Console.WriteLine("=============== End of process, hit any key to finish ===============");
            Console.WriteLine();
            Console.ReadKey();

            Console.WriteLine("Now executing MatrixFactorization recommendation for users: 346, 350, 387, 392, 338, 411, 393, 497, 324, 502, 590, 579");
            var samples = new int[] { 346, 350, 387, 392, 338, 411, 393, 497, 324, 502, 590, 579 };

            var listOfNodesToTry = new SortedSet<float>();
            foreach (var session in sessions)
            {
                foreach (var visit in session.PageVisits)
                {
                    listOfNodesToTry.Add(visit.NodeId);
                }
            }

            string modelPath = "../../../../WPVML_TrainerML.Model/UserMatrix.zip";
            ITransformer mlModel = mlContext.Model.Load(modelPath, out var modelInputSchema);
            var predictionengine = mlContext.Model.CreatePredictionEngine<UserMatrix, UserMatrixOutput>(mlModel);

            foreach (var i in samples)
            {
                UserMatrixDataBuild(i, listOfNodesToTry, predictionengine);
            }
        }

        private static void UserMatrixDataBuild(int user, SortedSet<float> listOfNodesToTry, PredictionEngine<UserMatrix, UserMatrixOutput> predictionengine)
        {
            var highestScore = new KeyValuePair<float, float>();

            foreach (var node in listOfNodesToTry)
            {
                var sampleData = new UserMatrix()
                {
                    UserId = user,
                    NodeId = node
                };

                UserMatrixOutput predictionResult = Executor.PredictUserMatrix(sampleData, predictionengine);
                if (predictionResult.Score > highestScore.Value)
                {
                    highestScore = new KeyValuePair<float, float>(sampleData.NodeId, predictionResult.Score);
                }

            }

            Console.WriteLine($"Highest score for user {user}: {highestScore}");
        }








        private static MostImportantPageOutput PredictMostImportantPage(MostImportantPage sampleData)
        {
            SdcaMaximumEntropy.CreateModel();
            return Executor.PredictSdca(sampleData);
        }

        private static ExternalDataOutput predictExternalDataClusters(ExternalData sampleData)
        {
            return Executor.PredictExternalDataClusters(sampleData);
        }

        private static void KMeansDataBuild(Session session)
        {
            var sampleData = new ExternalData()
            {
                Rain = Convert.ToSingle(session.Weather.Rain),
                Temperature = (float)session.Weather.Temperature,
                Day = session.DateTime.Day,
                Hour = session.DateTime.Hour,
                WindSpeed = (float)session.Weather.WindSpeed,
                Cloudiness = session.Weather.Cloudiness
            };

            var predictionResult = predictExternalDataClusters(sampleData);
        }

        private static void EvaluateKMeans(List<Session> sessions)
        {
            List<ExternalData> dataForTestingKMeans = new List<ExternalData>();
            foreach (var session in sessions)
            {
                dataForTestingKMeans.Add(new ExternalData()
                {
                    Rain = Convert.ToSingle(session.Weather.Rain),
                    Temperature = (float)session.Weather.Temperature,
                    Day = session.DateTime.Day,
                    Hour = session.DateTime.Hour,
                    WindSpeed = (float)session.Weather.WindSpeed,
                    Cloudiness = session.Weather.Cloudiness
                });
            }

            KMeans.calculateWSS(dataForTestingKMeans, 25);
        }
    }
}
